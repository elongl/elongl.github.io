---
layout: post
title:  CVE-2014-3153
date:   2021-01-08
categories: exploitation
---


# Understanding The Kernel
For quite some time now, I've been wanting to unveil the internals of modern operating systems.  
I didn't like how the most basic and fundamental level of a computer was so abstract to me,  
and that I did not _truly_ grasp how some of it works, a "blackbox".  

I've always been more than familiar with kernel and OS concepts,  
but there's a big gap from comprehending them as a user versus a kernel hacker.  
I wanted to see code.

In order to tackle that,  
I decided to take on a small kernel exploit [challenge], and in parallel read [Linux Kernel Development].  
Initially, the thought of reading the kernel's code seemed a bit scary, _"I wouldn't understand a thing"_.
Little by little, it wasn't as intimidating, and honestly, it turned out to be quite easier than I expected.  

Now, I feel tenfolds more comfortable to simply look something up in the source in order to understand how it works,
rather than searching man pages endlessly or consulting other people.

![Linux Kernel Image]

# Kernel Exploitation
The book was really nice and all, but I wanted to get my hands dirty.  
I searched for a disclosed vulnerability within the Linux kernel,  
my plan being that I'd read its flat description and develop my own exploit to it.  
A friend recommended [CVE-2014-3153], also known as _Towelroot_, and I just went for it.

# Fast Userspace Locking (Futex)
The vulnerability is based around a mechanism called _Futex_ within the kernel.  
Which, you guessed it, is a wordplay on Fast-Mutex.
> The futex() system call provides a method for waiting until a
  certain condition becomes true.  It is typically used as a
  blocking construct in the context of shared-memory
  synchronization.  When using futexes, the majority of the
  synchronization operations are performed in user space.  A user-
  space program employs the futex() system call only when it is
  likely that the program has to block for a longer time until the
  condition becomes true.  Other futex() operations can be used to
  wake any processes or threads waiting for a particular condition.

I will cover **only** the terms and concepts related to the exploitation.  
For a more profound insight about futexes, please reference [man futex(2)] and [man futex(7)].  
I strongly suggest messing around with the examples in order to assess your understanding.

In my own words, futexes are used as a synchronization mechanism in programs where a lock (mutex) is likely to be held long enough so that
you'd want your task to not be scheduled by the kernel (sleep) until that lock is available. Unlike [busy waiting].

The `futex()` syscall isn't typically used by "everyday" programs, but rather by system libraries such as `pthreads` that wrap its usage.
That's why the syscall doesn't have a glibc wrapper like most syscalls invoked from userspace do,
in order to call it, one has to use `syscall(SYS_futex, ...)`.

Due to the blocking nature of `futex()` and it being a way to synchronize between different tasks,  
you'd notice how there's a lot of dealing with threads within the exploit which can get very confusing unless approached slowly.

There are two core concepts to understand about locks in general which we'd talk a lot about.  
The first is something's called a _waiters list_. In essence, it means the blocking threads that are currently waiting for a lock to be released.  

The second is that there are two kinds of futexes: PI & non-PI.  
PI stands for [Priority Inheritance].
>  Priority inheritance is a mechanism for dealing with the
   priority-inversion problem.  With this mechanism, when a high-
   priority task becomes blocked by a lock held by a low-priority
   task, the priority of the low-priority task is temporarily raised
   to that of the high-priority task, so that it is not preempted by
   any intermediate level tasks, and can thus make progress toward
   releasing the lock.

This introduces the ability to prioritize waiters among the futex's waiters list.  
A higher-priority task is guaranteed to get the lock faster than a lower-priority task.  
Unlike non-PI operations, for instance.
> FUTEX_WAKE  
  This operation wakes at most val of the waiters that are
  waiting (e.g., inside FUTEX_WAIT) on the futex word at the
  address uaddr.  Most commonly, val is specified as either
  1 (wake up a single waiter) or INT_MAX (wake up all
  waiters).  No guarantee is provided about which waiters
  are awoken (e.g., a waiter with a higher scheduling
  priority is **not guaranteed** to be awoken in preference to a
  waiter with a lower priority).

Both of which are used within the exploit.

# Bug & Vulnerability
Here's the CVE description.
> The futex_requeue function in kernel/futex.c in the Linux kernel through 3.14.5
  does not ensure that calls have two different futex addresses, which allows local users to gain privileges
  via a crafted FUTEX_REQUEUE command that facilitates unsafe waiter modification.

Let's break it down.  
First, we need to understand what's a requeue operation in the context of futexes.  
A waiter, blocking thread, that is contending on a lock,
can be "requeued" by a running thread to be told to wait on a different lock instead of the one it currently waits on.

A non-PI futex can be requeued to either a different non-PI futex, or to a PI-futex.  
A PI-futex cannot be requeued.  
The bug itself is that there are no validations whatsoever on requeuing from a futex to itself.  

By doing that, we can requeue a PI-futex to itself (PI --> PI), which clearly violates the following policy.
> FUTEX_CMP_REQUEUE_PI  
  Requeues waiters that are blocked via
  FUTEX_WAIT_REQUEUE_PI on uaddr from a **non-PI source** futex
  (uaddr) to a **PI target** futex (uaddr2).

Take a look at the [bug fix commit], both the description and the code changes.  
Though, what actually happens when you requeue a futex to itself? Good question.

Before actually diving into the exploit, I decided to provide a rough overview of how it works for context further on.
Eventually, what this bug gives us is a **dangling waiter** within the futex's waiters list.
The way the exploit does that is as follows:

**Step** | **Operation** | **Description**
1\. | `FUTEX_LOCK_PI` | Lock the PI futex.
2\. | `FUTEX_WAIT_REQUEUE_PI` | Wait on non-PI futex, with the intention of being requeued to the PI futex.
3\. | `FUTEX_CMP_REQUEUE_PI` | Requeue the non-PI futex onto the PI futex.
4\. | Userspace Overwrite | Set the PI futex's value to `0` so that the kernel treats it as free.
5\. | `FUTEX_CMP_REQUEUE_PI` | Requeue the PI futex to **itself**.

And now we'll understand why.

There are a lot of different data types within the Futex's implementation code,  
in order to cope with that I made somewhat of a [summary of them] to help me keep track of what's going on.
Feel free to use it as needed.

**Step 2**

In order to requeue a non-PI --> PI futex, we first have to invoke `FUTEX_WAIT_REQUEUE_PI` on the non-PI futex,
which in turn translates to the [`futex_wait_requeue_pi`] function.  
What this function does is take a non-PI futex and wait (`FUTEX_WAIT`) on it,
and a PI-futex that it can _potentially_ be requeued to with a `FUTEX_CMP_REQUEUE_PI` command later on.

```c
static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,
				 u32 val, ktime_t *abs_time, u32 bitset,
				 u32 __user *uaddr2)
{
	struct hrtimer_sleeper timeout, *to = NULL;
	struct rt_mutex_waiter rt_waiter; // <-- Important
	struct rt_mutex *pi_mutex = NULL;
	struct futex_hash_bucket *hb;
	union futex_key key2 = FUTEX_KEY_INIT;
	struct futex_q q = futex_q_init;
	int res, ret;
  ...
```

The function defines various local variables, the most important of which is the `rt_waiter` variable.  
Needless to say that the locals are placed on the kernel stack,
but also worth mentioning that because it'll be crucial to understand in the near future.

Later on, it initializes the futex queue entry and enqueues it.  
```c

	q.bitset = bitset;
	q.rt_waiter = &rt_waiter;
	q.requeue_pi_key = &key2;
  ...
	/* Queue the futex_q, drop the hb lock, wait for wakeup. */
	futex_wait_queue_me(hb, &q, to);
```

At this point in the code, the function simply blocks and does not continue unless:  
  1. A wakeup occurs.
  2. The process is killed.

**Step 5 (Self-requeuing, after first requeue)**

Next up, [`futex_requeue`] is called by the `FUTEX_CMP_REQUEUE_PI` operation in order to do the heavy lifting of actually requeuing the futex.
The function is fairly long and therefore I'm not going to review all of its logic, and rather only address the relevant parts.
I do encourage you to brief over it and try to get a rough overview of what it does.

There are two interesting sections within this function.  
The first of which is [the call](https://elixir.bootlin.com/linux/v3.11.4/source/kernel/futex.c#L1353) to [`futex_proxy_trylock_atomic`].

```c
if (requeue_pi && (task_count - nr_wake < nr_requeue)) {
		/*
		 * Attempt to acquire uaddr2 and wake the top waiter. If we
		 * intend to requeue waiters, force setting the FUTEX_WAITERS
		 * bit.  We force this here where we are able to easily handle
		 * faults rather in the requeue loop below.
		 */
		ret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,
						 &key2, &pi_state, nr_requeue);
     ...
```

Let's take a look at `futex_proxy_trylock_atomic`.
```c
/*
 * Return:
 *  0 - failed to acquire the lock atomically;
 *  1 - acquired the lock;
 * <0 - error
 */
static int futex_proxy_trylock_atomic(u32 __user *pifutex,
				 struct futex_hash_bucket *hb1,
				 struct futex_hash_bucket *hb2,
				 union futex_key *key1, union futex_key *key2,
				 struct futex_pi_state **ps, int set_waiters)
{
  ...
  /*
	 * Try to take the lock for top_waiter.  Set the FUTEX_WAITERS bit in
	 * the contended case or if set_waiters is 1.  The pi_state is returned
	 * in ps in contended cases.
	 */
	ret = futex_lock_pi_atomic(pifutex, hb2, key2, ps, top_waiter->task,
				   set_waiters);
	if (ret == 1)
		requeue_pi_wake_futex(top_waiter, key2, hb2);

	return ret;
}
```
Basically all it does is call [`futex_lock_pi_atomic`] and if the lock was acquired,  
wake up the top waiter.

```c
static int futex_lock_pi_atomic(u32 __user *uaddr, struct futex_hash_bucket *hb,
				union futex_key *key,
				struct futex_pi_state **ps,
				struct task_struct *task, int set_waiters)
{
	int lock_taken, ret, force_take = 0;
	u32 uval, newval, curval, vpid = task_pid_vnr(task);

retry:
	ret = lock_taken = 0;

	/*
	 * To avoid races, we attempt to take the lock here again
	 * (by doing a 0 -> TID atomic cmpxchg), while holding all
	 * the locks. It will most likely not succeed.
	 */
	newval = vpid;
	if (set_waiters)
		newval |= FUTEX_WAITERS;

	if (unlikely(cmpxchg_futex_value_locked(&curval, uaddr, 0, newval)))
		return -EFAULT;
	...
	/*
	 * Surprise - we got the lock. Just return to userspace:
	 */
	if (unlikely(!curval))
		return 1;
	...
```

The function attempts to [atomically] compare-and-exchange the futex with `0` which is the value that signals the lock is free.
This operation is `unlikely` to succeed because the user could've done it in userspace and avoid the expensive syscall,
therefore the assumption is that the user wasn't able to retrieve the lock in userspace and needed the kernel's help,
that's why it would be a "surprise" in case it _was able_ to get the lock.

Recalling the function above, if we successfully took control of the lock, we'd wake the top waiter,
which is the waiter that was added to the waiters list on the first requeue (non-PI --> PI).
Because we overwrote the value in userspace, the function succeeds and wakes the waiter.

[challenge]: https://github.com/elongl/pwnable.kr/tree/master/syscall
[Linux Kernel Development]: https://books.google.co.il/books/about/Linux_Kernel_Development.html?id=3MWRMYRwulIC
[Linux Kernel Image]: https://www.cloudhostnews.com/wp-content/uploads/2020/11/Linux-Kernel-5.8-Reaches-EOL-Users-Advised-to-Upgrade-to-Linux-5.9-Series.png
[CVE-2014-3153]: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-3153
[man futex(2)]: https://man7.org/linux/man-pages/man2/futex.2.html
[man futex(7)]: https://man7.org/linux/man-pages/man7/futex.7.html
[busy waiting]: https://en.wikipedia.org/wiki/Busy_waiting
[Priority Inheritance]: https://en.wikipedia.org/wiki/Priority_inheritance 
[bug fix commit]: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e9c243a5a6de0be8e584c604d353412584b592f8
[summary of them]: https://github.com/elongl/CVE-2014-3153/blob/master/notes.md#data-structures
[`futex_requeue`]: https://elixir.bootlin.com/linux/v3.11.4/source/kernel/futex.c#L1264
[`futex_wait_requeue_pi`]: https://elixir.bootlin.com/linux/v3.11.4/source/kernel/futex.c#L2285
[`futex_proxy_trylock_atomic`]: https://elixir.bootlin.com/linux/v3.11.4/source/kernel/futex.c#L1202
[`futex_lock_pi_atomic`]: https://elixir.bootlin.com/linux/v3.11.4/source/kernel/futex.c#L718
[atomically]: https://wiki.osdev.org/Atomic_operation
