---
layout: post
title:  CVE-2014-3153
date:   2021-01-08
categories: exploitation
---


# Understanding The Kernel
For quite some time now, I've been wanting to unveil the internals of modern operating systems.  
I didn't like how the most basic and fundamental level of a computer was so abstract to me,  
and that I did not _truly_ grasp how some of it works, a "blackbox".  

I've always been more than familiar with kernel and OS concepts,  
but there's a big gap from comprehending them as a user versus a kernel hacker.

In order to tackle that,  
I decided to take on a small kernel exploit [challenge], and in parallel read [Linux Kernel Development].  
Initially, the thought of reading the kernel's code seemed a bit scary, _"I wouldn't understand a thing"_.
Little by little, it wasn't as intimidating, and honestly, it turned out to be quite easier than I expected.  

Now, I feel tenfolds more comfortable to simply look something up in the source in order to understand how it works,
rather than searching man pages endlessly or consulting other people.

![Linux Kernel Image]

# Kernel Exploitation
The book was really nice and all, but I wanted to get my hands dirty.  
I searched for a disclosed vulnerability within the Linux kernel,  
my plan being that I'd read its flat description and develop my own exploit to it.  
A friend recommended [CVE-2014-3153], also known as _Towelroot_, and I just went for it.

# Fast Userspace Locking (Futex)
The vulnerability is based around a mechanism called _Futex_ within the kernel.  
Which, you guessed it, is a wordplay on Fast-Mutex.
> The futex() system call provides a method for waiting until a
  certain condition becomes true.  It is typically used as a
  blocking construct in the context of shared-memory
  synchronization.  When using futexes, the majority of the
  synchronization operations are performed in user space.  A user-
  space program employs the futex() system call only when it is
  likely that the program has to block for a longer time until the
  condition becomes true.  Other futex() operations can be used to
  wake any processes or threads waiting for a particular condition.

I will cover **only** the terms and concepts related to the exploitation.  
For a more profound insight about futexes, please reference [man futex(2)] and [man futex(7)].  
I strongly suggest messing around with the examples in order to assess your understanding.

In my own words, futexes are used as a synchronization mechanism in programs where a lock (mutex) is likely to be held long enough so that
you'd want your task to not be scheduled by the kernel (sleep) until that lock is available. Unlike [busy waiting].

The `futex()` syscall isn't typically used by "everyday" programs, but rather by system libraries such as `pthreads` that wrap its usage.
That's why the syscall doesn't have a glibc wrapper like most syscalls invoked from user-space do,
in order to call it, one has to use `syscall(SYS_futex, ...)`.

Due to the blocking nature of `futex()` and it being a way to synchronize between different tasks,  
you'd notice how there's a lot of dealing with threads within the exploit which can get very confusing unless approached slowly.

There are two core concepts to understand about locks in general which we'd talk a lot about.  
The first is something's called a _waiters list_. In essence, it means the blocking threads that are currently waiting for a lock to be released.  

The second is that there are two kinds of futexes: PI & non-PI.  
PI stands for [Priority Inheritance].
>  Priority inheritance is a mechanism for dealing with the
   priority-inversion problem.  With this mechanism, when a high-
   priority task becomes blocked by a lock held by a low-priority
   task, the priority of the low-priority task is temporarily raised
   to that of the high-priority task, so that it is not preempted by
   any intermediate level tasks, and can thus make progress toward
   releasing the lock.

This introduces the ability to prioritize waiters among the futex's waiters list.  
A higher-priority task is guaranteed to get the lock faster than a lower-priority task.  
Unlike non-PI operations, for instance.
> FUTEX_WAKE  
  This operation wakes at most val of the waiters that are
  waiting (e.g., inside FUTEX_WAIT) on the futex word at the
  address uaddr.  Most commonly, val is specified as either
  1 (wake up a single waiter) or INT_MAX (wake up all
  waiters).  No guarantee is provided about which waiters
  are awoken (e.g., a waiter with a higher scheduling
  priority is **not guaranteed** to be awoken in preference to a
  waiter with a lower priority).

Both of which are used within the exploit.

# Bug & Vulnerability
Here's the CVE description.
> The futex_requeue function in kernel/futex.c in the Linux kernel through 3.14.5
  does not ensure that calls have two different futex addresses, which allows local users to gain privileges
  via a crafted FUTEX_REQUEUE command that facilitates unsafe waiter modification.

Let's break it down.  
First, we need to understand what's a requeue operation in the context of futexes.  
A waiter, blocking thread, that is contending on a lock,
can be "requeued" by a running thread to be told to wait on a different lock instead of the one it currently waits on.

A non-PI futex can be requeued to either a different non-PI futex, or to a PI-futex.  
A PI-futex cannot be requeued.  
The bug itself is that there are no validations whatsoever on requeueing from a futex to itself.  

By doing that, we can requeue a PI-futex to itself (PI --> PI), which clearly violates the following policy.
> FUTEX_CMP_REQUEUE_PI  
  Requeues waiters that are blocked via
  FUTEX_WAIT_REQUEUE_PI on uaddr from a **non-PI source** futex
  (uaddr) to a **PI target** futex (uaddr2).

Take a look at the [bug fix commit], both the description and the code changes.  
Though, what actually happens when you do that? Good question.

There are a lot of different data types within the Futex's implementation code,  
in order to cope with that I made somewhat of a [summary of them] to help me keep track of what's going on.
Feel free to use it as needed.

In order to requeue a non-PI --> PI futex, we first have to invoke `FUTEX_WAIT_REQUEUE_PI` on the non-PI futex,
which in turn translates to the [`futex_wait_requeue_pi`] function.  
What this function does is take a non-PI futex and wait (`FUTEX_WAIT`) on it,
and a PI-futex that it can _potentially_ be requeued to with a `FUTEX_CMP_REQUEUE_PI` command later on.

```c
static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,
				 u32 val, ktime_t *abs_time, u32 bitset,
				 u32 __user *uaddr2)
{
	struct hrtimer_sleeper timeout, *to = NULL;
	struct rt_mutex_waiter rt_waiter; // <-- Important
	struct rt_mutex *pi_mutex = NULL;
	struct futex_hash_bucket *hb;
	union futex_key key2 = FUTEX_KEY_INIT;
	struct futex_q q = futex_q_init;
	int res, ret;
  ...
```
The function defines various local variables, the most important of which is the `rt_waiter` variable.  
Needless to say that the locals are placed on the kernel stack,
but also worth mentioning that because it'll be crucial to understand in the near future.

Later on, it initializes the futex queue entry and enqueues it.  
```c
	q.bitset = bitset;
	q.rt_waiter = &rt_waiter;
	q.requeue_pi_key = &key2;
  ...
	/* Queue the futex_q, drop the hb lock, wait for wakeup. */
	futex_wait_queue_me(hb, &q, to);
```
At this point in the code, the function simply blocks and does not continue unless:  
  1. A wakeup occurs.
  2. The process is killed.




[challenge]: https://github.com/elongl/pwnable.kr/tree/master/syscall
[Linux Kernel Development]: https://books.google.co.il/books/about/Linux_Kernel_Development.html?id=3MWRMYRwulIC
[Linux Kernel Image]: https://www.cloudhostnews.com/wp-content/uploads/2020/11/Linux-Kernel-5.8-Reaches-EOL-Users-Advised-to-Upgrade-to-Linux-5.9-Series.png
[CVE-2014-3153]: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-3153
[man futex(2)]: https://man7.org/linux/man-pages/man2/futex.2.html
[man futex(7)]: https://man7.org/linux/man-pages/man7/futex.7.html
[busy waiting]: https://en.wikipedia.org/wiki/Busy_waiting
[Priority Inheritance]: https://en.wikipedia.org/wiki/Priority_inheritance 
[bug fix commit]: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e9c243a5a6de0be8e584c604d353412584b592f8
[summary of them]: https://github.com/elongl/CVE-2014-3153/blob/master/notes.md#data-structures
[`futex_requeue`]: https://elixir.bootlin.com/linux/v3.11.4/source/kernel/futex.c#L1264
[`futex_wait_requeue_pi`]: https://elixir.bootlin.com/linux/v3.11.4/source/kernel/futex.c#L2285