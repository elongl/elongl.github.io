---
layout: post
title:  CVE-2014-3153
date:   2021-01-08
categories: exploitation
---


# Understanding The Kernel
For quite some time now, I've been wanting to unveil the internals of modern operating systems.  
I didn't like how the most basic and fundamental level of a computer was so abstract to me,  
and that I did not _truly_ grasp how some of it works, a "blackbox".  

I've always been more than familiar with kernel and OS concepts,  
but there's a big gap from comprehending them as a user versus a kernel hacker.

In order to tackle that,  
I decided to take on a small kernel exploit [challenge], and in parallel read [Linux Kernel Development].  
Initially, the thought of reading the kernel's code seemed a bit scary, _"I wouldn't understand a thing"_.
Little by little, it wasn't as intimidating, and honestly, it turned out to be quite easier than I expected.  

Now, I feel tenfolds more comfortable to simply look something up in the source in order to understand how it works,
rather than searching man pages endlessly or consulting other people.

![Linux Kernel](https://www.cloudhostnews.com/wp-content/uploads/2020/11/Linux-Kernel-5.8-Reaches-EOL-Users-Advised-to-Upgrade-to-Linux-5.9-Series.png)

# Kernel Exploitation
The book was nice and all, but I wanted to get my hands dirty.  
I searched for a disclosed vulnerability within the Linux kernel,  
my plan being that I'd read its flat description and develop my own exploit to it.  
A friend recommended [CVE-2014-3153], also known as _Towelroot_, and I just went for it.

# Fast Userspace Locking (Futex)
The vulnerability is based around a mechanism called _Futex_ within the kernel.  
> The futex() system call provides a method for waiting until a
  certain condition becomes true.  It is typically used as a
  blocking construct in the context of shared-memory
  synchronization.  When using futexes, the majority of the
  synchronization operations are performed in user space.  A user-
  space program employs the futex() system call only when it is
  likely that the program has to block for a longer time until the
  condition becomes true.  Other futex() operations can be used to
  wake any processes or threads waiting for a particular condition.

I will cover **only** the terms and concepts related to the exploitation.  
For a more profound insight about futexes, please reference [man futex(2)] and [man futex(7)].  
I strongly suggest messing around with the examples in order to assess your understanding.

In my own words, futexes are used as a synchronization mechanism in programs where a lock (mutex) is likely to be held long enough so that
you'd want your task to not be scheduled by the kernel (sleep) until that lock is available. Unlike [busy waiting].

The `futex()` syscall isn't typically used by "everyday" programs, but rather by system libraries such as `pthreads` that wrap its usage.
That's why the syscall doesn't have a glibc wrapper like most syscalls invoked from user-space do,
in order to call it, one has to use `syscall(SYS_futex, ...)`.

Due to the blocking nature of `futex()` and it being a way to synchronize between different tasks,  
you'd notice how there's a lot of dealing with threads within the exploit which can get very confusing unless approached slowly.

There are two core concepts to understand about locks in general which we'd talk a lot about.  
The first is something's called a _"waiters list"_. In essence, it means the blocking threads that are currently waiting for a lock to be released.  

The second is that there are two kinds of futexes: PI & Non-PI.  
PI stands for [Priority Inheritance].
>  Priority inheritance is a mechanism for dealing with the
   priority-inversion problem.  With this mechanism, when a high-
   priority task becomes blocked by a lock held by a low-priority
   task, the priority of the low-priority task is temporarily raised
   to that of the high-priority task, so that it is not preempted by
   any intermediate level tasks, and can thus make progress toward
   releasing the lock.

This introduces the ability to prioritize waiters among the futex's waiters list.  
A higher-priority task is guaranteed to get the lock faster than a lower-priority task.



[challenge]: https://github.com/elongl/pwnable.kr/tree/master/syscall
[Linux Kernel Development]: https://books.google.co.il/books/about/Linux_Kernel_Development.html?id=3MWRMYRwulIC
[CVE-2014-3153]: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-3153
[man futex(2)]: https://man7.org/linux/man-pages/man2/futex.2.html
[man futex(7)]: https://man7.org/linux/man-pages/man7/futex.7.html
[busy waiting]: https://en.wikipedia.org/wiki/Busy_waiting
[Priority Inheritance]: https://en.wikipedia.org/wiki/Priority_inheritance 
